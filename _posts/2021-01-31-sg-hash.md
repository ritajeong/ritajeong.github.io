---
layout: post
title: "CS study) Data Structure- Hash"
subtitle: ""
categories: sg
tags: sg
comments: true
date: 2021-01-31 09:13:00 -0400
---

## 해시 개념     
해시를 한 마디로 정의해보자.     
**"해시함수를 거친 key, value를 연관배열 구조에 저장한다"**
<img src="/assets/img/posts/20210131hash.png">      

## 해시 과정
    Key를 해시함수에 입력하면, 출력으로 Hashcode를 얻는다.       
    이 Hashcode를 인덱스로 갖는 배열에 저장한다.  이 때 Hashcode는 key와 매칭하여 저장한다. 
<img src="/assets/img/posts/Cap 2021-01-31 11-59-43-129">

## 해시 용어
- **Key** : 해시함수의 input. 고유한 값이다.   
다양한 길이의 값이 될 수 있다. 문자열, 숫자, 파일데이터도 가능하다.     
입력이 무제한이다.  
- **Hash(Hashcode, Value)** : 해시함수의 output.     
저장소에서 주소로 사용하고 key와 매칭된다.  
- **Bucket, Slot** : 연관배열인 저장소를 지칭한다.    
- **Hash function** : key를 hash로 바꾸는 기능을 한다.    
제각각인 key를 일정한 길이의 hash로 변경하여 저장소를 효율적으로 관리한다.(무한한 값->유한한 값)    
한글자만 변경되도 전혀 다른 해쉬 값을 생성한다.     
**결정론적 함수** : 해시함수는 입력이 동일하면 항상 동일한 출력을 낸다.     
**일방향 함수** : 해시 함수의 출력을 통해 거꾸로 원본 값을 구하는 것은 일반적으로 불가능하다. 즉, 암호화-복호화 과정이 불가능하다.  

## 해시 충돌 - 해시테이블의 숙제
    입력값은 무한하지만 출력값이 유한하므로 '비둘기집 원리'에 의해 해시충돌은 피할 수 없다.
    해시함수가 서로 다른 두 입력값에 대해 동일한 메모리 위치를 반환하는 경우 해시 충돌이 일어났다고 말한다.    
    해시 충돌을 해결하는 방법으로 유명한 체이닝과 개방주소법을 알아보자.    

### **체이닝(Chaining)**     
    한 인덱스에 연결된 해시값을 체인처럼 줄줄이 달아놓는 경우.  
    버켓 내에 연결리스트(Linked List)를 할당하여, 버켓에 데이터를 삽입하다가 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식이다.   
    이 때 데이터의 주소값은 바뀌지 않는다.   
<img src="/assets/img/posts/20210131hash-chaining.png">     

    그림을 보면, John Smith와 Sandra Dee가 152의 인덱스로 충돌이 발생했다.  
    체이닝 기법을 이용하여 152의 인덱스에서 John Smith 다음에 Snadra Dee를 리스트로 달아놓은 걸 확인할 수 있다.     
<img src="/assets/img/posts/20210131hash-chaining2.png">  


    **장점**    
    해시함수의 의존도가 낮아짐.  
    메모리 사용량이 낮고 공간을 추가적으로 확보할 필요가 없다.  
    **단점**    
    클러스터 현상이 생겨서 검색속도가 낮아질 수 있다.    
    리스트 공간이 따로 필요하다.    

### **개방 주소법(Open Addressing)**     
버켓 중 비어있는 공간을 할당한다. 
체이닝의 경우 버켓이 꽉 차더라도 연결리스트로 계속 늘려가기에, 데이터의 주소값은 바뀌지 않는다.(Closed Addressing)  
하지만 개방 주소법의 경우에는 다르다.   
해시 충돌이 일어나면 다른 버켓에 데이터를 삽입하는 방식을 개방 주소법이라고 한다.   
<img src="/assets/img/posts/20210131hash-openAdressing.png">        
위 그림은 선형탐색으로 해시충돌을 해결한 경우다.    
John Smith와 Sandre Dee의 화살표 부분을 보면 873의 인덱스로 동일하게 향하는 것을 알 수 있다.    
이 경우, 1만큼 건너뛴 874의 자리에 Sandra Dee를 저장했다.

     **장점**    
    해시함수의 의존도가 낮아짐.  
    메모리 사용량이 낮고 공간을 추가적으로 확보할 필요가 없다.  
    **단점**    
    클러스터 현상이 생겨서 검색속도가 낮아질 수 있다.    
    리스트 공간이 따로 필요하다.    

개방 주소법에서 가장 중요한 이슈는 **load factor**이다.  
load factor는 해시테이블의 크기를 m, 실제 사용하는 키 개수를 n이라고 할 때 n/m이다. 
이것은 사용되는 배열의 버킷 비율, 즉 얼만큼 배열이 꽉 차있는지 여부이다.   
만약 테이블이 가득 차있다면, 주어진 키를 찾거나 삽입하는데 프로브의 수가 크게 증가하고, 프로빙 알고리즘이 종료되지 않을 수도 있다.  
따라서, 좋은 해시 함수를 사용하더라도 load factor의 계수는 보통 80%로 제한한다.  
열악한 해시 함수는 특히 가장 간단한 선형 주소 지정 방법을 사용하여 상당한 클러스터링을 생성하여 매우 낮은 부하 요인에서도 성능이 저하 될 수 있다.   
일반적으로 대부분의 개방형 주소 지정 방법을 사용하는 일반적인로드 요소는 50 %이지만 별도의 체인은 일반적으로 최대 100 %를 사용할 수 있다.   


개방 주소법의 종류는 다음과 같다.
- 선형 탐색(Linear Probing): 다음 버켓, 혹은 몇 개를 건너뛰어 데이터를 삽입한다.
- 제곱 탐색(Quadratic Probing): 제곱만큼 건너뛴 버켓에 데이터를 삽입(1,4,9,16..)
- 이중 해시(Double Hashing): 다른 해시함수를 한 번 더 적용한 결과를 이용함.


## 리사이징
Separate changing에 경우, 버켓이 일정 수준으로 차 버리면 각 버켓에 연결되어 있는 List의 길이가 늘어나기 때문에, 검색 성능이 떨어지기 때문에 버켓의 개수를 늘려줘야 한다.    
Open addressing의 경우, 고정 크기 배열을 사용하기 때문에 데이터를 더 넣기 위해서는 배열을 확장해야 한다. 이를 리사이징(Resizing)이라고 한다.

확장하는 임계점은 현재 데이터 개수가 해시 버켓의 개수의 75%가 될 때이다.(=load factor가 0.75일 때)
크기는 보통 이전 테이블의 두 배로 확장한다.
값 복사에 대해서는, 새로운 array에 hash를 다시 계산해서 복사해줘야 한다.  

- 왜 75%인가?   
통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.    
리사이징은 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확정을 하지 않도록 테이블을 설계해주어야 한다.  


## 대표적인 해시 함수
해시함수로 해시충돌을 완화하는 방법이다.    
  - **Division Method**: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.( 주소 = 입력값 % 테이블의 크기) 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.      
  - **Digit Folding** : 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.     
  - **Multiplication Method** : 숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다. h(k)=(kAmod1) × m
  - **Univeral Hashing** : 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.     

더 자세한 내용은 [이곳을 참고하세요](https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/)

## 해시의 장점
- 해시 테이블은 Map, Set을 구현하는데 자주 사용된다.  
- 항목의 추가,제거가 트리 기반의 데이터구조에 비해 빠르다.    
- 적은 리소스로 많은 데이터를 효율적으로 관리할 수 있다.
- 배열의 인덱스(index)를 사용해서 검색, 삽입, 삭제가 빠르다. (평균 시간복잡도 : O(1))
- 키(key)와 해시값(Hash)이 연관성이 없어 보안에도 많이 사용된다.



## 해시의 단점
-  충돌이 발생할 수 있다.   
    충돌을 해결하려는 논문은 지금도 활발히 연구중이다.    
- 공간복잡도가 커진다.     
    올바르게 동작하기 위해 대량의 연속적 메모리 공간이 필요하다.    
    데이터가 저장되기 전에 미리 저장공간을 확보해 놓아야 한다.  
    공간이 부족하거나 아예 채워지지 않은 경우가 생길 가능성이 있다.        
- 순서가 있는 배열에는 어울리지 않는다.    
   상하관계가 있거나, 순서가 중요한 데이터의 경우 Hash Table을 쓰지 않는 게 좋다.       
   순서와 상관없이 key만을 가지고 hash를 찾아 저장하기 때문이다.   
- 해시 함수 의존도가 높아진다.     
   평균 데이터 처리의 시간복잡도는 O(1)이지만, 이는 해시 함수의 연산을 고려하지 않는 결과이다.  
   해시함수가 매우 복잡하다면 해시테이블의 모든 연산의 시간 효율성은 증가할 것이다.     


## 해시테이블의 성능
통상적으로 해시함수의 복잡도를 배제하고 복잡도를 따진다.    
키값이 배열의 인덱스로 변환되기 때문에 탐색, 저장, 삭제가 빠르다.   
해시테이블의 삽입,삭제,검색의 평균 시간복잡도는 O(1)이지만 최악의 경우 O(N)이다.     
해시 충돌이 발생할 경우 모든 bucket의 value들을 찾아봐야하기 때문이다.   
- 삽입, 삭제는 O(1)인 이유?     
여기서의 인덱스는 데이터만의 고유한 위치이기 때문에 만약 삽입이나 삭제를 한다고 해도 다른 데이터로 채울 필요가 없다. 즉, 삽입이나 삭제할 때 데이터를 이동할 필요가 없기 때문이다.

## 해시와 해킹
Dictionary and Brute Force Attacks, Lookup tables, Reverse Lookup Tables, Rainbow Tables 등의 방법으로 해시 해킹이 이루어진다.  
Rainbow Table : 해시함수로 출력된 값을 모두 저장한 표. 해시값과 대조하여 입력값을 찾아낼 수 있다.   
이를 방지하기 위해 Salt를 주로 사용한다.    
Salt : key에 salt를 붙여서 해시함수에 입력한다. 이 때 salt는 무작위 문자열이다. 암호학적으로 안전한 난수 생성기에 의해 만들어져야한다.(CSPRNG) 사용자와 비밀번호별로 유일한 값을 만들어야한다.  

## 해시가 쓰이는 곳
- 유튜브에서 중복영상 체크
- 블록체인의 공공장부 비교


출처 : 
책) 컴퓨터 과학 로드맵(인사이트)     
웹사이트)
이미지 출처 : [위키피디아](https://en.wikipedia.org/wiki/Open_addressing)
대표적인 해시함수 부분 참고 : [mangkty 블로그](https://mangkyu.tistory.com/102)
개방주소법 부분 참고 :  [Preamtree의 행복로그](https://preamtree.tistory.com/20)
리사이징 부분 참고 : [조대협](https://bcho.tistory.com/1072)
해시와 해킹 부분 참고 : [비밀번호 털렸다고? 암호화. 해시함수. 5분 설명. -노마드코더](https://youtu.be/67UwxR3ts2E)  
해시와 해킹 부분 참고 : [Salted Password Hashing - Doing it Right](https://crackstation.net/hashing-security.htm#javasourcecode)    
해시와 해킹 부분 참고 : [비밀번호 해시에 소금치기 - 바르게 쓰기](https://starplatina.tistory.com/entry/%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%ED%95%B4%EC%8B%9C%EC%97%90-%EC%86%8C%EA%B8%88%EC%B9%98%EA%B8%B0-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%93%B0%EA%B8%B0)   

해시가 쓰이는 곳 참고(영상 내 인트로)[[자료구조 알고리즘] 해쉬테이블(Hash Table)에 대해 알아보고 구현하기- 엔지니어 대한민국](https://youtu.be/Vi0hauJemxA)