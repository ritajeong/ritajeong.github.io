---
layout: post
title: "바킹독의 실전 알고리즘 0x01강 오리엔테이션"
subtitle: "강의를 듣고 요약한 기록입니다"
categories: problem-solving
tags:  barkingdog algorithm class youtube ot
comments: true
date: 2020-07-27 18:34:00 -0400
---
 
 ## 서론

 기초코드 작성요령1

 쉽다기 보다 중요해서 기초인 부분!
 
 ## 목차

 0. 시간, 공간복잡도

 1. 정수 자료형

 2. 실수 자료형


 # 0. 시간, 공간복잡도

 시간제한 알아보기.
 
 1초에 3~5억개의 연산을 처리가능
 
 
 시간복잡도와 빅오표기법.
 
 O(n) : 걸리는 시간이 n에 비례함
 
 O(lgn)

 1 < lgn < n < nlgn < n^2 < 2^n < n!
 
<img src="/img/posts/2020-07-27-1.jpg" >
![title](/img/posts/2020-07-27-1.jpg){: width="100%" height="100%"}
n<=백만개 일때, O(n)정도면 1초안에 연산이 이루어짐 (어림)

### 내 풀이의 시간복잡도 파악하기

초보 단계에서 시간복잡도를 파악하는 게 쉽지 않다.

예시1~4


## 공간복잡도

512MB = 1.2억개의 int

기억하기) int는 4바이트니까,


## 정수 자료형

1byte = 8bit

char에서는 맨 왼쪾이 -2^7이다.

논리회로, 2의 보수 참고.


00001001 //unsigned char에서는 0

10000011 //                    1

00001011 // char에서는 0

10000011 //            -125


unsigned char는 0~2^7(0~255)

char에서는 -2^7~ 2^6(-128~-127)


int의 최댓값이 21억

long long 80번의 피보나치수 


### integer overflow
char 01111111 (127)에서

1을 더하면 -128이 된다.

이것을 방지하는 방법은 각 자료형의 범위에 맞는 값을 가지게끔 연산을 시키면 된다. 


예시함수 3가지


## 실수 자료형
IEEE-754

실수의 성질은 꼭 기억하기.

1. 실수는 저장/연산 과정에서 반드시 오차가 발생할 수밖에 없다.

float : 유효숫자 6자리, double : 15자리

절대/상대오차를 허용하다는 단서 확인하기.

이것이 없다면 거의 다 정수에서 해결할 수 있는 문제임.


2. double의 long long 범위의 정수를 함부로 담으면 안된다.

double은 유효숫자 15자리, longlong은 19자리

오차섞인 값이 저장 될 수 있음.

10의 18승과 10의 18승+1이 구분되지 않고 같은 값이 저장된다.

그러나 int는 최대 21억이기 때문에 double에 잠길 수 있다.


3. 실수를 비교할 때는 등호를 사용하면 안 된다.

 1e-12 // 10^(-12)와 같은 표현
 
 1e9 // 10^(9)


 sign field, exponent field // IEEE 754 표현법
 
 지금 어렵다면 나중에라도 찾아보기